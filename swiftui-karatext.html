<link rel="import" href="swiftui-karatext-import.html">

<polymer-element name="swiftui-karatext" attributes="start end">
	<template>
		<span id="canvas">
		</span>
  </template>
	
	<script>
		(function() {
			var lineSpacing = 30;
			
			var parentHeight;
			var firstLineTop, secondLineTop;
			
			
			/* Helper functions */
			/* ====================== */
			
			function numberToPx(number) {
				return number + "px"; 
			}
			
			function getMilliseconds(timestampStr) {
				var timestampStrSplit = timestampStr.split(".");
				var milli = Date.parse("January 1, 1970 " + timestampStrSplit[0] + " UTC");
				if (timestampStrSplit.length == 1)
					return milli;
				else (timestampStrSplit.length == 2)
					return milli + parseInt(timestampStrSplit[1] * 100);
			}
			
			/* ====================== */
			
			
			
			Polymer({
				_getStyles: function() {
					return window.getComputedStyle(this);
				},
				
				_getGroundTextColorForSVG: function() {
					return this._getStyles().backgroundColor;
				},
				
				_getForegroundTextColorForSVG: function() {
					return this._getStyles().color;
				},
				
				_getFontSizeForSVG: function() {
					return parseInt(this._getStyles().fontSize, 10);
				},
				
				registerTimes: function(currentTime, prevEndTime) {
					/* For type = 2 lines,
					/* 1. i-th karatext will fly to 2nd line at the time its previous starts playing
					/* 2. i-th karatext will fly to 1st line at the time its previous ends playing (or flies out)
					/* == */
					
					/* Formulas:
					/* 1. flyTo2[i] = start[i-1]
					/* 2. flyTo1[i] = end[i-1]
					/* == */
					
					/* Conditions:
					/* 1. 1st formula must be to satisfy the criteria that no overlapping text occurs at 2nd line:
					/* flyTo2[i] >= flyTo1[i-1] <=> start[i-1] >= end[i-2] <=> start[i] >= end[i-1],
					/* which is obvious, a karatext's timestamp must not be overlapping with its neighbor's timestamp.
					/* 2. 2nd formula always satisfies the criteria that no overlapping text occurs at 1st line.
					/* == */
					
					this._flyTo2LineTime = 0; // = prevStartTime - currentTime
					this._flyTo1LineTime = prevEndTime - currentTime;
					this._realStartTime = this.startTime - currentTime;
					this._realEndTime = this.endTime - currentTime;
				},
				
				/* This function is used for stopped */
				reset: function() {
					this._filledBackground.attr({"width": 0});
				},
				
				/* This function is used for pausing */
				stop: function() {
					this.cancelAsync(this._showTimer);
					this.cancelAsync(this._flyTo2LineTimer);
					this.cancelAsync(this._flyTo1LineTimer);
					this._filledBackground.stop();
					this._filledBackground.attr({"width": 0});
					this.cancelAsync(this._endTimer);
					this.cancelAsync(this._hideTimer);
					
					if (this.style.display != "none") {
						this._cancelFallTimer = this.async(function() {
							document.timeline.play(new Animation(this,
								[
									{opacity: 1, top: this._getStyles().top},
									{opacity: 0, top: numberToPx(parentHeight)}
								],
								{
									duration: 200,
									easing: "ease-out",
									fill: "both"
								}));
						});
						this._cancelHideTimer = this.async(function() {
							this.style.display = "none";
						}, null, 200);
					}
				},
				
				/* This function is used for playing */
				run: function(flyDuration) {
					this.cancelAsync(this._cancelFallTimer);
					this.cancelAsync(this._cancelHideTimer);
					
					/* Show */
					this._showTimer = this.async(function() {
						this.style.display = "block";
						this.style.position = "absolute";
						this.style.width = "100%";
						this.style.opacity = "0";
						this.style.height = numberToPx(this._textHeight);
					}, null, this._flyTo2LineTime);
					
					/* Fly in to second line */
					this._flyTo2LineTimer = this.async(function() {
						document.timeline.play(new Animation(this,
							[
								{opacity: 0, top: numberToPx(parentHeight)},
								{opacity: 1, top: numberToPx(secondLineTop)}
							],
							{
								duration: flyDuration,
								easing: "ease-out",
								fill: "both"
							}));
					}, null, this._flyTo2LineTime);
					
					/* Fly to first line */
					this._flyTo1LineTimer = this.async(function() {
						document.timeline.play(new Animation(this,
							[
								{top: numberToPx(secondLineTop)},
								{top: numberToPx(firstLineTop)}
							],
							{
								duration: flyDuration,
								easing: "ease",
								fill: "forwards"
							}));
					}, null, this._flyTo1LineTime);
					
					/* Run text */
					this._filledBackground
						.animate({duration: this.duration, ease: "<>", delay: this._realStartTime})
						.attr({"width": this._textWidth});
					
					/* Fly out */
					this._endTimer = this.async(function() {
						document.timeline.play(new Animation(this,
							[
								{opacity: 1, top: numberToPx(firstLineTop)},
								{opacity: 0, top: numberToPx(-this._textHeight)}
							],
							{
								duration: flyDuration,
								easing: "ease-in",
								fill: "forwards"
							}));
					}, null, this._realEndTime);
					
					/* Hide */
					this._hideTimer = this.async(function() {
						this.style.display = "none";
					}, null, this._realEndTime + flyDuration);
				},
				
				
				/* Polymer lifecycle functions */
				/* ====================== */
				
				publish: {
					start: "0:0:0",
					end: "0:0:0"
				},
				
				ready: function() {
					this.startTime = getMilliseconds(this.start);
					this.endTime = getMilliseconds(this.end);
					this.duration = this.endTime - this.startTime;
				},
				
				domReady: function() {
					this.async(function() {
						var svgCanvas = SVG(this.$.canvas);

						/* Drawing texts: ground and clipping text */
						var text = svgCanvas.text(this.textContent);
						text.attr("font-family", null); // A hack to remove SVG.js default font value
						text.attr("fill", this._getGroundTextColorForSVG()); // Set ground text color by using background-color CSS
						var textLeading = this._getFontSizeForSVG() / 16.0 - 0.3;
						text.leading(textLeading);

						var clippingText = svgCanvas.text(this.textContent);
						clippingText.attr("font-family", null);
						clippingText.attr("fill", this._getGroundTextColorForSVG());
						clippingText.leading(textLeading);

						/* After using the background-color CSS to color ground text, reset the element background */
						this.style.backgroundColor = "transparent";

						/* Calculate the real bounding size */
						this._textWidth = Math.round(text.node.getBBox().width);
						this._textHeight = Math.round(text.node.getBBox().height);
						
						/* Set size for the svgCanvas */
						svgCanvas.size(this._textWidth, this._textHeight);

						/* Color and clip */
						this._filledBackground = svgCanvas.rect(0, this._textHeight).fill(this._getForegroundTextColorForSVG());
						this._filledBackground.clipWith(clippingText);

						/* Hide this before made shown again when playing */
						this.style.display = "none";

						/* Calculate some global vars, only once */
						if (firstLineTop === undefined && this._textHeight > 0) {
							parentHeight = this.parentNode.clientHeight;

							firstLineTop = (parentHeight - lineSpacing) / 2 - this._textHeight;
							secondLineTop = firstLineTop + this._textHeight + lineSpacing;
						}

						this.parentNode.registerKaratext(this);
					});
				}
				
				/* ====================== */
				
			});
		})();
	</script>
</polymer-element>