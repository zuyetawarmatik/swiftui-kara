<link rel="import" href="swiftui-karatext-import.html">

<polymer-element name="swiftui-karatext" attributes="start end">
	<template>
		<style>
			::content swiftui-karaword {
				display: none;
			}
			swiftui-karaword {
				display: none;
			}
		</style>
		<span id="canvas"></span>
		<content select="swiftui-karaword"></content>
  </template>
	
	<script>
		(function() {
			var lineSpacing = 30;
			
			var parentHeight;
			var firstLineTop, secondLineTop;
			
			/* Helper functions */
			/* ====================== */
			
			function numberToPx(number) {
				return number + "px"; 
			}
			
			function getMilliseconds(timestampStr) {
				var timestampStrSplit = timestampStr.split(".");
				var milli = Date.parse("January 1, 1970 " + timestampStrSplit[0] + " UTC");
				if (timestampStrSplit.length == 1)
					return milli;
				else (timestampStrSplit.length == 2)
					return milli + parseInt(timestampStrSplit[1] * 100);
			}
			
			/* ====================== */
			
			
			
			Polymer({
				_getStyles: function() {
					return window.getComputedStyle(this);
				},
				
				_getGroundTextColorForSVG: function() {
					return this._getStyles().backgroundColor;
				},
				
				_getForegroundTextColorForSVG: function() {
					return this._getStyles().color;
				},
				
				_getFontSizeForSVG: function() {
					return parseInt(this._getStyles().fontSize, 10);
				},
				
				registerTimes: function(currentTime, prevEndTime) {
					/* For type = 2 lines,
					/* 1. i-th karatext will fly to 2nd line at the time its previous starts playing
					/* 2. i-th karatext will fly to 1st line at the time its previous ends playing (or flies out)
					/* == */
					
					/* Formulas:
					/* 1. flyTo2[i] = start[i-1]
					/* 2. flyTo1[i] = end[i-1]
					/* == */
					
					/* Conditions:
					/* 1. 1st formula must be to satisfy the criteria that no overlapping text occurs at 2nd line:
					/* flyTo2[i] >= flyTo1[i-1] <=> start[i-1] >= end[i-2] <=> start[i] >= end[i-1],
					/* which is obvious, a karatext's timestamp must not be overlapping with its neighbor's timestamp.
					/* 2. 2nd formula always satisfies the criteria that no overlapping text occurs at 1st line.
					/* == */
					
					this._flyTo2LineTime = 0; // = prevStartTime - currentTime
					this._flyTo1LineTime = prevEndTime - currentTime;
					this._realStartTime = this.startTime - currentTime;
					this._realEndTime = this.endTime - currentTime;
				},
				
				/* This function is used for stopped */
				reset: function() {
					this.style.display = "none";
					for (var i = 0; i < this._words; i++) {
						this._filledBackground[i].attr({"width": 0});
					}
				},
				
				/* This function is used for pausing */
				stop: function() {
					this.cancelAsync(this._showTimer);
					this.cancelAsync(this._flyTo2LineTimer);
					this.cancelAsync(this._flyTo1LineTimer);
					for (var i = 0; i < this._words; i++) {
						this._filledBackground[i].stop();
						this._filledBackground[i].attr({"width": 0});
					}
					this.cancelAsync(this._endTimer);
					this.cancelAsync(this._hideTimer);
					
					if (this.style.display != "none") {
						this._cancelFallTimer = this.async(function() {
							document.timeline.play(new Animation(this,
								[
									{opacity: 1, top: this._getStyles().top},
									{opacity: 0, top: numberToPx(parentHeight)}
								],
								{
									duration: 200,
									easing: "ease-out",
									fill: "both"
								}));
						});
						this._cancelHideTimer = this.async(function() {
							this.style.display = "none";
						}, null, 200);
					}
				},
				
				// TODO: remove flyDuration
				/* This function is used for playing */
				run: function(flyDuration) {
					this.cancelAsync(this._cancelFallTimer);
					this.cancelAsync(this._cancelHideTimer);
					
					/* Show */
					this._showTimer = this.async(function() {
						this.style.display = "block";
						this.style.position = "absolute";
						this.style.width = "100%";
						this.style.opacity = "0";
						this.style.height = numberToPx(this._textHeight);
					}, null, this._flyTo2LineTime);
					
					/* Fly in to second line */
					this._flyTo2LineTimer = this.async(function() {
						document.timeline.play(new Animation(this,
							[
								{opacity: 0, top: numberToPx(parentHeight)},
								{opacity: 1, top: numberToPx(secondLineTop)}
							],
							{
								duration: flyDuration,
								easing: "ease-out",
								fill: "both"
							}));
					}, null, this._flyTo2LineTime);
					
					/* Fly to first line */
					this._flyTo1LineTimer = this.async(function() {
						document.timeline.play(new Animation(this,
							[
								{top: numberToPx(secondLineTop)},
								{top: numberToPx(firstLineTop)}
							],
							{
								duration: flyDuration,
								easing: "ease",
								fill: "forwards"
							}));
					}, null, this._flyTo1LineTime);
					
					/* Run words */
					for (var i = 0; i < this._words; i++) {
						this._filledBackground[i]
							.animate({duration: this.duration, ease: "<>", delay: this._realStartTime})
							.attr({"width": this._karawordSize[i].width});
					}
					
					/* Fly out */
					this._endTimer = this.async(function() {
						document.timeline.play(new Animation(this,
							[
								{opacity: 1, top: numberToPx(firstLineTop)},
								{opacity: 0, top: numberToPx(-this._textHeight)}
							],
							{
								duration: flyDuration,
								easing: "ease-in",
								fill: "forwards"
							}));
					}, null, this._realEndTime);
					
					/* Hide */
					this._hideTimer = this.async(function() {
						this.style.display = "none";
					}, null, this._realEndTime + flyDuration);
				},
				
				
				/* Polymer lifecycle functions */
				/* ====================== */
				
				publish: {
					start: "0:0:0",
					end: "0:0:0"
				},
				
				created: function() {
					if (this.querySelectorAll("swiftui-karaword").length == 0) {
						var karaword = document.createElement("swiftui-karaword");
						karaword.setAttribute("start", this.start);
						karaword.setAttribute("end", this.end);
						karaword.textContent = this.textContent;
						this.appendChild(karaword);
					}
				},
				
				ready: function() {
					this._filledBackground = [];
					this._karawordSize = [];
					
					this.startTime = getMilliseconds(this.start);
					this.endTime = getMilliseconds(this.end);
					this.duration = this.endTime - this.startTime;
					
					this._words = this.querySelectorAll("swiftui-karaword").length;
				},
				
				domReady: function() {
					this.async(function() {
						/* Calculate some vars */
						var groundTextColor = this._getGroundTextColorForSVG();
						var foregroundTextColor = this._getForegroundTextColorForSVG();
						var textLeading = this._getFontSizeForSVG() / 16.0 - 0.3;
						
						/* After using the background-color CSS to get ground text color, reset the element background */
						this.style.backgroundColor = "transparent";
						
						/* SVG canvas */
						var svgCanvas = SVG(this.$.canvas);
						
						/* Calculate a space width */
						var temp = svgCanvas.text("a b");
						temp.attr("font-family", null);
						var tempWidth1 = temp.node.getBBox().width;
						temp.remove();
						temp = svgCanvas.text("ab");
						var tempWidth2 = temp.node.getBBox().width;
						var wordSpaceWidth = Math.round(tempWidth1 - tempWidth2);
						temp.remove();
						
						/* Drawing */
						var karawords = this.querySelectorAll("swiftui-karaword");
						for (var i = 0; i < this._words; i++) {
							var karaword = karawords[i];
							var wordContent = karaword.textContent.trim();
							
							var wordDx;
							if (i == 0)
								wordDx = 0;
							else
								wordDx = this._karawordSize[i-1].dx + this._karawordSize[i-1].width + wordSpaceWidth;
							
							/* Drawing words: ground and clipping word */
							var word = svgCanvas.text(wordContent);
							word.attr("font-family", null); // A hack to remove SVG.js default font value
							word.attr("fill", groundTextColor); // Set ground text color by using background-color CSS
							word.leading(textLeading);
							word.dx(wordDx);
							
							var clippingWord = svgCanvas.text(wordContent);
							clippingWord.attr("font-family", null);
							clippingWord.attr("fill", groundTextColor);
							clippingWord.leading(textLeading);
							clippingWord.dx(wordDx);
							
							/* Calculate the real bounding size */
							var wordWidth = Math.round(word.node.getBBox().width);
							var wordHeight = Math.round(word.node.getBBox().height);
							this._karawordSize.push({
								dx: wordDx,
								width: wordWidth,
								height: wordHeight
							});
							
							/* Color and clip */
							var rect = svgCanvas.rect(0, wordHeight).fill(foregroundTextColor).dx(wordDx);
							this._filledBackground.push(rect);
							this._filledBackground[i].clipWith(clippingWord);
						};
						
						/* Set size for the svgCanvas */
						this._textWidth = 0;
						this._textHeight = this._karawordSize[0].height;
						for (var i = 0; i < this._words; i++) {
							this._textWidth += this._karawordSize[i].width;
							if (i != 0) this._textWidth += wordSpaceWidth;
						};

						svgCanvas.size(this._textWidth, this._textHeight);

						/* Hide this before made shown again when playing */
						this.style.display = "none";

						/* Calculate some global vars, only once */
						if (firstLineTop === undefined && this._textHeight > 0) {
							parentHeight = this.parentNode.clientHeight;

							firstLineTop = (parentHeight - lineSpacing) / 2 - this._textHeight;
							secondLineTop = firstLineTop + this._textHeight + lineSpacing;
						}

						this.parentNode.registerKaratext(this);
					});
				}
				
				/* ====================== */
				
			});
		})();
	</script>
</polymer-element>